# BOJ_Algorithm_Study
백준 알고리즘 어렵게 풀었던 문제들 기록

### 1076번 : 저항 
* 나 : 색, 값, 곱의 데이터를 전부 배열로 생성해서 입력받은 값을 배열끼리 비교하고 처음 받은 두 값은 String으로 붙이고 마지막 값은 int형으로 곱했다.
* 타인 : 색만 배열로 생성하고 입력값과 색 배열이 같은 경우에 i의 값을 이용하여 값과 곱을 구하고 마지막에 연산하여 결과를 구했다.
* 결론 : 내 코드는 형변환이 자주 일어나는 데에 비해서 다른 사람의 코드는 그럴 필요가 없다.

### 1110번 : 더하기 사이클
* 나 : 나름 간단한 코드를 사용해 완성했다고 생각했다.
* 타인 : do-while을 이럴때 활용하면 좋다는 것을 알았다.
* 결론 : 처음 연산과 반복적인 연산이 조금 다르다면 do-while을 

### 1629번 : 곱셈
* 나 : 그냥 제곱해서 나머지만 구하면 되는 단순한 문제인 줄 알았으나 굉장히 수학적인 방법이 필요했던 문제였다.(못품)
* 타인 : 수학 공식을 이용하여 코드로 옮겨서 풀었음(https://onsil-thegreenhouse.github.io/programming/problem/2018/03/29/problem_math_power/)
* 결론 : 어떤 방식으로 풀었는지 느낌으로는 이해가 가지만 정확한 이해는 아직 못한것같다.

### 1764번 : 듣보잡
* 나 : 배부른 마라토너 문제에서 이용했던 알고리즘과 유사하여 HashMap으로 시도했으나 HashMap은 정렬이 안되서 TreeMap으로 바꿔주고 풀었다.
* 결론 : 얼떨결에 TreeMap도 살짝 알게되었다.

### 1924번 : 2007년
* 나 : 월,일을 받고 String 변수로 날짜 형식에 맞게 저장을 해준 뒤 날짜 함수를 이용하여 해당 날짜에 속하는 요일을 출력하였다.
* 타인 : 월별로 일 수를 배열로 저장하고 요일도 배열로 저장했다. 1월부터 입력달 -1 월 까지의 일 수를 다 더하고 7로 나눈 나머지를 구하면 원하는 요일을 출력할 수 있다.
* 결론 : 날짜 함수를 이용한 것 보다 코드가 더 간단하다.

### 1978번 : 소수찾기
* 나 : 소수가 되기위한 조건을 코드로 적용해서 풀었지만 코드가 길다.
* 타인 : 소수가 되기위한 조건을 코드로 적용해서 푼건 동일하나 나보다 코드가 짧다.
* 결론 : 소수가 되기위한 조건 자체는 쉬운데 코드로 표현하기가 어려웠던 것 같다.

### 2010번 : 플러그
* 나 : 쓸데없는 변수와 if문의 남발 전형적인 생각안하고 막 작성한 코드, 내가 풀고나서 나중에보니 이해가 안되는 코드다.
* 나2 : 나중에 다시 풀어본 코드, 이해하기도 쉽고 더 간결해졌다.
* 결론 : 항상 푸는 방법을 먼저 생각해보고 코드로 옮기는 것이 옳다.

### 2455번 : 지능형 기차
* 나 : 2010번처럼 내가 풀었지만 왜 이렇게 풀었는지 이해를 할 수 없는 코드다.
* 나2 : 제대로 된 방법을 생각하고 코드로 옮겼다.
* 결론 : 문제 푸는 방식을 찾아내고 간결하게 표현할 줄 알아야한다.

### 2864번 : 5와 6의 차이 
* 나 : 문제 푸는 방법과 코드 자체는 이해하기 쉽고 괜찮다고 생각한다.
* 나2 : replace 함수를 쓰기 전까지는 처음 코드가 괜찮은줄 알았다.
* 결론 : 함수만 잘써도 코드가 반으로 줄어든다.

### 2577번 : 숫자의 개수
* 나 : 숫자를 입력받고 스플릿으로 나누고 미리 숫자가 저장된 배열과 비교하여 같으면 증가시켜준다.
* 나2: 숫자를 입력받고 곱한값을 % 10으로 연산하고 그 값을 배열의 인덱스에 넣어 증가시켰다.
* 타인 : 나2에서 한 코드와 원리는 똑같지만 코드가 더 짧다.
* 결론 : 코드는 줄일수록 좋은것 같다.

### 2675번 : 문자열 반복
* 나 : 문자열을 반복하는 방식을 split 함수를 사용하였다.
* 타인 : 문자열 반복하는 방식을 char.At을 사용하였고 마지막에 replace 함수를 이용해 공백제거를 하였다.
* 결론 : 알고리즘 자체는 쉬우나 어떤 함수를 사용하는가에 따라서 코드만 달라진다.

### 2869번 : 달팽이는 올라가고 싶다
* 나 : 스스로 테스트케이스를 여러개 만들어 직접 실험해보고 규칙을 찾아내 코드로 적용하였고 정상 출력되지만 백준에선 틀렸다고 나왔고 더 많은 숫자로 실험을 해본 결과 반올림이 아닌 올림을 해줘야 하는 것을 찾았고 성공했다.
* 타인 : 반복문을 이용하여 풀었다. 내 기억에 반복문을 썼을 때 시간초과라고 나왔던 것 같은데 반복문이 간단해서 통과하는 듯 하다.
* 결론 : 숫자를 가지고 노는 문제는 규칙을 찾아내는게 최우선이다.

### 2920번 : 음계
* 나 : 비교용 배열을 생성하고 다른 배열에 입력을 받고 배열끼리 자리의 값을 비교하여 결과를 출력했다.
* 타인 : 배열에 입력을 받고 그 배열만을 사용하여 자리수 연산을 통해 결과를 출력하였다.
* 결론 : 배열간의 자리수를 이용한 문제를 풀 때 굳이 다른 배열을 생성해 줄 필요는 없다.

### 4673번 : 셀프넘버
* 나 : boolean 배열을 생성하고 숫자마다 각 자리수로 잘라서 다 더해준다음 그 값을 배열의 자리값으로 지정해 true로 바꿔주고 false값만 출력
* 타인 : 알고리즘 자체는 같다. 하지만 자리수를 나눠서 더해주는 방법을 코드로 구현한 부분이 엄청난 차이가 있다. 
* 결론 : 자리수를 나눠서 더하는 방법은 생각보다 간단하다.

### 10546번 : 배부른 마라토너
* 나 : 맵을 사용하지 않고 배열과 반복문을 이용하여 풀어서 결과는 나왔지만 시간초과로 성공하지 못했다.
* 타인 : 맵을 사용하여 풀었다.
* 결론 : 맵을 사용할 줄 알면 더 편하게 풀 수 있다.

### 10808번 : 알파벳 개수 
* 나 : 알파벳을 하나씩 배열에 저장하고, 입력받은 문자열을 잘라서 배열과 배열을 비교하여서 숫자를 증가시켰다.
* 타인 : 입력한 문자열에서 'a'를 뺀 값을 배열의 자리수로 만들어 숫자를 증가시켰다. (아스키코드 사용)
* 결론 : 코드의 길이부터 확연한 차이가 있고 아스키코드를 잘 이용할 줄 알면 코드 수를 줄일 수 있음을 알았다. 

### 10952번 : A+B - 5 
* 나 : 두 숫자가 0을 받기 전까지 숫자를 더한 값을 스트링버퍼에 저장하고 0을 받으면 한번에 나오도록 출력했다.
* 타인 : 숫자를 입력 받고 0이 아니면 바로 나오도록 출력했다.
* 결론 : 문제에서 예제로 준 출력값이 항상 한번에 다 나와야 하는 줄 알고 스트링버퍼를 썼는데 그게 아니었다..

### 14568번 : 2017 연세대학교 프로그래밍 경시대회(사탕 나눠주기)
* 나 : 규칙에 맞게 사탕이 나눠지는 경우의 수를 따져서 일정한 방식을 찾았지만 코드로 구현해내지 못했다..
* 타인 : 내가 찾은 일정한 규칙의 수열을 구현해냈다.(사탕을 나눠주는 방식에 대한 것은 코드에 나타나지 않는다.)
* 타인2 : 사탕을 나눠주는 방식을 코드로 구현해내고 조건이 다 맞는다면 카운트하는 방식의 코드다.
* 결론 : 문제에서 제시한 규칙에서 어떤것을 우선적으로 보느냐에 따라 문제를 푸는 방식이 달라지는 것을 알았다.
